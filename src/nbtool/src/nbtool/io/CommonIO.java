package nbtool.io;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.EOFException;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketTimeoutException;
import java.nio.channels.UnresolvedAddressException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.LinkedList;

import javax.swing.SwingUtilities;

import nbtool.data.Log;
import nbtool.util.Center;
import nbtool.util.Center.ToolEvent;
import nbtool.util.Events.EventListener;
import nbtool.util.Logger;
import nbtool.util.NBConstants;
import nbtool.util.Utility;

public class CommonIO {

	public static void writeLog(DataOutputStream dos, Log l) throws IOException {
		byte[] cbytes = l.description().getBytes(StandardCharsets.UTF_8);
		byte[] dbytes = l.bytes;

		//Ensure string is null-terminated.
		dos.writeInt(cbytes.length + 1);
		dos.write(cbytes);
		dos.writeByte(0);

		if (l.bytes != null) {
			dos.writeInt(dbytes.length);
			dos.write(dbytes);
		} else {
			dos.writeInt(0);
		}

		dos.flush();
	}

	public static Log readLog(DataInputStream dis) throws IOException {
		String desc = readLogDescription(dis);

		int len = dis.readInt();
		//U.w("COMMON IO: data len " + len);
		byte[] dbytes = new byte[len];
		dis.readFully(dbytes);

		return new Log(desc, dbytes);
	}
	
	public static Log simpleReadLog(DataInputStream dis) throws IOException {
		String desc = readLogDescription(dis);

		int len = dis.readInt();
		byte[] dbytes = new byte[len];
		dis.readFully(dbytes);

		Log ret = new Log();
		ret.bytes = dbytes;
		ret._olddesc_ = desc;
		return ret;
	}

	public static String readLogDescription(DataInputStream dis) throws IOException {
		int len = -1;
		len = dis.readInt();
		//U.w("COMMON IO: desc len " + len);
		byte[] cbytes = new byte[len];
		dis.readFully(cbytes);

		String desc = new String(cbytes);
		desc = desc.replace("\0", "");	//Remove any null characters.

		return desc;
	}

	/*
	 * If you're wondering why there's no explicit load log function: 'loading' a log should be done by reading the log in fully, then checking that the read description matches the log's original description.
	 * */


	/*
	 * Can't use (host, port) constructor because it doesn't allow setting of timeout.
	 * */
	protected static Socket setupNetSocket(String addr, int port) throws IOException {
		Socket newsock = new Socket();

		InetSocketAddress address = new InetSocketAddress(addr, port);
		if (address.isUnresolved()) {
			Logger.logf(Logger.ERROR, "CommonIO.setupNetSocket(): ERROR: Could not resolve address: " + addr);
			throw new UnresolvedAddressException();
		}
		try {
			newsock.connect(new InetSocketAddress(addr, port), NBConstants.SOCKET_TIMEOUT);
		} catch (SocketTimeoutException ste) {
			Logger.logf(Logger.ERROR, "CommonIO.setupNetSocket() could not connect to socket within timeout!");
			throw ste;
		}

		return newsock;
	}
	
	public static enum IOState {
		STARTING,
		RUNNING,
		ENDING,
		FINISHED,
	}

	public static abstract class IOInstance implements Runnable {
		protected IOFirstResponder ifr;
		
		protected volatile IOState state = IOState.STARTING;
		protected IOState state() { return state; }

		protected Socket socket = null;
		
		protected String host;
		protected int port;

		public void kill() {
			
			if (state == IOState.FINISHED)
				return;

			synchronized(this) {
				state = IOState.ENDING;
				
				if (socket != null) {
					try {
						socket.close();
					} catch (IOException e) {
						Logger.log(Logger.INFO, "Exception generated by IOInstance.kill():");
						e.printStackTrace();
					}
				}
			}
		}
		
		protected void finish() {
			synchronized(this) {
				state = IOState.FINISHED;
				
				if (socket != null) {
					try {
						socket.shutdownInput();
						socket.shutdownOutput();
						socket.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
					socket = null;
				}
			}
		}
		
		public String host() {
			return host;
		}
		
		public int port() {
			return port;
		}
		
		public abstract String name();
	}

	protected static class SequenceErrorException extends Exception {
		private static final long serialVersionUID = 1L;
		public int expected, was;
		SequenceErrorException(int e, int w) {
			super();
			expected = e; was = w;
		}
		
		@Override
		public String toString() {
			return String.format("SequenceError: wanted %d, got %d.", expected, was);
		}
	}
	
	public static interface IOFirstResponder {
		public void ioFinished(IOInstance instance);
		public void ioReceived(IOInstance inst, int ret, Log ... out);
		
		/* !CALLED ASYNCHRONOUSLY! */
		public boolean ioMayRespondOnCenterThread(IOInstance inst);
	}
	
	public static final class GIOFirstResponder {
		public static void generateReceived(IOInstance instance, IOFirstResponder responder, int ret, Log ... logs) {
			if (instance == null || responder == null)
				return;
			
			IOReceived ior = new IOReceived();
			ior.instance = instance;
			ior.responder = responder;
			ior.ret = ret;
			ior.logs = logs;
			
			Center.addEvent(ior);
		}
		
		public static void generateFinished(IOInstance instance, IOFirstResponder responder) {
			if (instance == null || responder == null)
				return;
			
			IOFinished iof = new IOFinished();
			iof.instance = instance;
			iof.responder = responder;
			
			Center.addEvent(iof);
		}
	}
	
	protected static class IOReceived extends Center.ToolEvent {
		
		protected IOInstance instance;
		protected IOFirstResponder responder;
		protected int ret;
		protected Log[] logs;
		
		protected IOReceived() {}

		@Override
		protected boolean canCombine() { return false; }
		@Override
		protected void combine(LinkedList<ToolEvent> others) {}

		@Override
		protected Class<? extends EventListener> listenerClass() { return null; }

		@Override
		protected void execute(ArrayList<EventListener> guiList,
				ArrayList<EventListener> centerList) {
			
			assert(guiList == null && centerList == null);
			
			if (responder.ioMayRespondOnCenterThread(instance)) {
				responder.ioReceived(instance, ret, logs);
			} else {
				final IOInstance inst = instance;
				final IOFirstResponder resp = responder;
				final int r = ret;
				final Log[] out = logs;
				SwingUtilities.invokeLater(new Runnable(){
					@Override
					public void run() {
						resp.ioReceived(inst, r, out);
					}
				});
			}
			
		}
		
	}
	
	protected static class IOFinished extends Center.ToolEvent {
		protected IOInstance instance;
		protected IOFirstResponder responder;
		
		protected IOFinished() {}

		@Override
		protected boolean canCombine() { return false; }
		@Override
		protected void combine(LinkedList<ToolEvent> others) {}

		@Override
		protected Class<? extends EventListener> listenerClass() { return null; }

		@Override
		protected void execute(ArrayList<EventListener> guiList,
				ArrayList<EventListener> centerList) {
			
			assert(guiList == null && centerList == null);
			
			if (responder.ioMayRespondOnCenterThread(instance)) {
				responder.ioFinished(instance);
			} else {
				final IOInstance inst = instance;
				final IOFirstResponder resp = responder;
				SwingUtilities.invokeLater(new Runnable(){
					@Override
					public void run() {
						resp.ioFinished(inst);
					}
				});
			}
			
		}
		
	}
	
}
