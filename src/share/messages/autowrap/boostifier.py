import templates

def process_message(message, known_messages, known_enums, scope_stack = []):
    """
    Recursively parse a tokenized protobuf message structure
    Returns a string that represents the boost wrapped code
    for the C++ classes generated by the message structure
    """

    result = ""
    other_wrapped_objects = []

    message_name = message.name
    scoped_message_name = scope(message.name, scope_stack)
    result += templates.MESSAGE_SCOPE
    scope_stack.append(message.name)

    result += templates.MESSAGE_DECLARATION % locals()

    for element in message.elements:
        if 'message' in element:
            other_wrapped_objects += [process_message(element, known_messages, known_enums, scope_stack)]
        elif 'enum' in element:
            other_wrapped_objects += [process_enum(element, scope_stack)]
        elif 'flavor' in element:
            result += process_field(element, known_messages, known_enums, scope_stack)
        else:
            raise 'Unknown type of element ' + str(element)

    result += templates.MESSAGE_DECLARATION_END

    for other_wrapped_object in other_wrapped_objects:
        result += other_wrapped_object

    scope_stack.pop()
    result += templates.MESSAGE_SCOPE_END

    return result

def process_enum(enum, scope_stack):

    result = ""

    enum_name = enum.name
    scoped_enum_name = scope(enum.name, scope_stack)
    result += templates.ENUM_DECLARATION % locals()

    for enum_field in enum.elements:
        enum_field_name = enum_field.name
        enum_field_value = scope(enum_field_name, scope_stack)
        result += templates.ENUM_FIELD % locals()

    result += templates.ENUM_DECLARATION_END
    return result

def process_field(element, known_messages, known_enums, scope_stack):

    string_format = ""

    if element.flavor == 'repeated':
        if element.type in known_messages:
            string_format = templates.REPEATED_MESSAGE
        elif element.type in ['string', 'bytes']:
            string_format = templates.REPEATED_STRING
        else:
            string_format = templates.REPEATED_PRIMITIVE
    else:
        if element.type in known_messages:
            string_format = templates.SINGLE_MESSAGE
        elif element.type in ['string', 'bytes']:
            string_format = templates.SINGLE_STRING
        else:
            string_format = templates.SINGLE_PRIMITIVE

    field_name = element.name
    field_type = element.type
    # should probably check straightaway against a primitive list rather
    # than just assume all types that are not known are primitives
    # but it's 3:30 AM and I don't wanna figure it out right now
    if (field_type not in known_messages) and (field_type not in known_enums) and (field_type not in ['string', 'bytes']):
        field_type = '::google::protobuf::' + field_type
    scope = '::'.join(scope_stack)
    return string_format % locals()

def scope(name, scope_list, delimiter = '::'):
    return delimiter.join(scope_list + [name])

def repeated_message_def_template():
    return "\n\
    .def(\"add_repeated_{0}\", &{1}::add_repeated_{0}, return_value_policy<reference_existing_object>())\n\
    .def(\"repeated_{0}\", {1}_repeated_{0}_from_index, return_value_policy<reference_existing_object>())\n\
    .def(\"repeated_{0}_size\", &{1}::repeated_{0}_size)\n\
    .def(\"clear_repeated_{0}\", &{1}::clear_repeated_{0})\n"

def repeated_message_helper_alias_template():
    return "::{1}::{2}* ({1}::*{1}_repeated_{0}_from_index)(int) = &{1}::mutable_repeated_{0};"

def process_repeated_message(field, scope_stack):
    return { 'field': repeated_message_def_template().format(field['name'], '::'.join(scope_stack), field['type']) }

def repeated_string_def_template():
    return "\n\
    .def(\"add_repeated_{0}\", &{1}::add_repeated_{0})\n\
    .def(\"set_repeated_{0}\", &{1}::set_repeated_{0})\n\
    .def(\"repeated_{0}\", {1}_repeated_{0}_from_index)\n\
    .def(\"repeated_{0}_size\", &{1}::repeated_{0}_size)\n\
    .def(\"clear_repeated_{0}\", &{1}::clear_repeated_{0})"

def repeated_string_helper_alias_template():
    return "void ({1}::*{1}_set_{0})(const ::std::string&) = &{1}::set_{0};"

def process_repeated_string(field, scope_stack):
    return {'field': ''}#{ 'field': repeated_string_def_template().format(field['name'], '::'.join(scope_stack)),
            #'helper_alias': repeated_string_helper_alias_template().format('_'.join(scope_stack) + '_' + field['name'], '::'.join(scope_stack))}

def repeated_primitive_def_template():
    return "\n\
    .def(\"add_repeated_{0}\", &{1}::add_repeated_{0})\n\
    .def(\"set_repeated_{0}\", &{1}::set_repeated_{0})\n\
    .def(\"repeated_{0}\", {1}_repeated_{0}_from_index)\n\
    .def(\"repeated_{0}_size\", &{1}::repeated_{0}_size)\n\
    .def(\"clear_repeated_{0}\", &{1}::clear_repeated_{0})\n"

def process_repeated_primitive(field, scope_stack):
    return { 'field': single_primitive_def_template().format(field['name'], '::'.join(scope_stack))}
