import templates
import protobuf_defs

def process_message(message, known_messages, known_enums, scope_stack = []):
    """
    Recursively parse a tokenized protobuf message structure
    Returns a string that represents the boost wrapped code
    for the C++ classes generated by the message structure
    """

    result = ""
    other_wrapped_objects = []

    message_name = message.name
    scoped_message_name = scope(message.name, scope_stack)
    result += templates.MESSAGE_SCOPE
    scope_stack.append(message.name)

    result += templates.MESSAGE_DECLARATION % locals()

    for element in message.elements:
        if 'message' in element:
            other_wrapped_objects += [process_message(element, known_messages, known_enums, scope_stack)]
        elif 'enum' in element:
            other_wrapped_objects += [process_enum(element, scope_stack)]
        elif 'flavor' in element:
            result += process_field(element, known_messages, known_enums, scope_stack)
        else:
            raise 'Unknown type of element ' + str(element)

    result += templates.MESSAGE_DECLARATION_END

    for other_wrapped_object in other_wrapped_objects:
        result += other_wrapped_object

    scope_stack.pop()
    result += templates.MESSAGE_SCOPE_END

    return result

def process_enum(enum, scope_stack):

    result = ""

    enum_name = enum.name
    scoped_enum_name = scope(enum.name, scope_stack)
    result += templates.ENUM_DECLARATION % locals()

    for enum_field in enum.elements:
        enum_field_name = enum_field.name
        enum_field_value = scope(enum_field_name, scope_stack)
        result += templates.ENUM_FIELD % locals()

    result += templates.ENUM_DECLARATION_END
    return result

def process_field(element, known_messages, known_enums, scope_stack):

    string_format = ""

    field_name = element.name.lower() # protoc converts fieldnames to lower
    field_type = element.type
    scope = '::'.join(scope_stack)

    if element.flavor == 'repeated':
        if element.type in protobuf_defs.STRING_TYPES:
            string_format = templates.REPEATED_STRING
        elif element.type in known_enums:
            string_format = templates.REPEATED_PRIMITIVE
        elif element.type in protobuf_defs.PRIMITIVE_TYPES:
            field_type = '::google::protobuf::' + field_type
            string_format = templates.REPEATED_PRIMITIVE
        else:
            field_type = scoped_message_type(field_type, known_messages, scope_stack)
            string_format = templates.REPEATED_MESSAGE
    else:
        if element.type in protobuf_defs.STRING_TYPES:
            string_format = templates.SINGLE_STRING
        elif element.type in known_enums:
            string_format = templates.SINGLE_PRIMITIVE
        elif element.type in protobuf_defs.PRIMITIVE_TYPES:
            field_type = '::google::protobuf::' + field_type
            string_format = templates.SINGLE_PRIMITIVE
        else:
            field_type = scoped_message_type(field_type, known_messages, scope_stack)
            string_format = templates.SINGLE_MESSAGE

    return string_format % locals()

def scope(name, scope_list, delimiter = '::'):
    return delimiter.join(scope_list + [name])

def scoped_message_type(message, known_messages, scope_stack):
    """
    Recursively looks in the known message deep dictionary for the
    full scope of a message.
    E.g. for message = Foo, scope_stack = [Bar], and
    known_messages = {Bar: {Foo: {}}, Foo: {}}
    then the return will be Bar::Foo (and not Foo)
    """
    if len(scope_stack) == 0:
        if known_messages.has_key(message):
            return message
        else:
            return None

    scope = scope_stack.pop()

    unscoped_messages = known_messages[scope]
    found_message = scoped_message_type(message, unscoped_messages, scope_stack)

    scope_stack.append(scope)

    if found_message is None and known_messages.has_key(message):
        return message

    return scope + '::' + found_message
